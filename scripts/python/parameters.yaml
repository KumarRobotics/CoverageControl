# Assuming same resolution in both the directions. Pixel area = pResolution^2
pResolution: 1

# Actual size of maps is size * pResolution, e.g.,  pWorldMapSize * pResolution
# For ~1 km^2 actual environment, we have a 1024 grid world with each cell pResolution * pRobotMapSize=1 m^2
pWorldMapSize: 1024

# Robot map saves what the robot has seen
# Could make it sparse if size becomes a problem
pRobotMapSize: 1024
pUnknownImportance: 0.5 # fraction of the largest imaportance of a grid cell

# Local map is used for computing mass. Actual area would be pLocalMapSize * pResolution
# Should be greater than pCommunicationRange so that they can form different channels of the same image.
pLocalMapSize: 128
# Radius of communication (in meters)
pCommunicationRange: 128

# Set pUpdateRobotMap to false for centralized known world
pUpdateRobotMap: true
pUpdateSensorView: true

# Assuming square sensor FOV.
# Actual FOV: square with side pResolution * pSensorSize
# Robot is placed at the center of FOV
# Make it even so that I don't have to deal with substracting by half-resolution.
# Have made it to half of (pWorldMapSize - 1000 / pResolution)/2
# Positive integer. NOTE: Needs to be even
pSensorSize: 24

# Each time step corresponds to 0.1s, i.e., 10Hz
pTimeStep: 0.1
# in m/s. Make sure pMaxRobotSpeed * pTimeStep / pResolution < pSensorSize/2
pMaxRobotSpeed: 10
# Total time is pEpisodeSteps * pTimeStep
# This is not cause a hard constraint, but helpful for initializing vectors
pEpisodeSteps: 1000

# Bivariate Normal Distribution truncated after pTruncationBND * sigma
# Helps in reducing the number of erfc evaluations
# Needs testing to be sure that the probability masses are not significantly off
pTruncationBND: 4

# Used to normalize map. Max value will be scaled to pNorm.
pNorm: 1

# These settings are only required if the IDF is generated using random gaussians
pMinSigma: 6
pMaxSigma: 10
pMinPeak: 6
pMaxPeak: 10


# Settings for Lloyd offline algorithm
pLloydOfflineMaxIteration: 100
pLloydNumOfflineTries: 1
